
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Papers</title>
  <link rel="stylesheet" href="/_styles/citation.css">
  <link rel="stylesheet" href="/_styles/tags.css">
  <link rel="stylesheet" href="/_styles/button.css">
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f7f7f7;
    }
    .alps-header {
      background: #455a64;
      color: #fff;
      padding: 0;
      margin-bottom: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .alps-header-bar {
      display: flex;
      align-items: center;
      padding: 0 24px;
      height: 64px;
    }
    .alps-title {
      font-size: 2rem;
      font-weight: bold;
      margin-right: 32px;
    }
    .alps-nav {
      display: flex;
      gap: 8px;
    }
    .alps-nav a {
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      padding: 8px 16px;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .alps-nav a:hover {
      background: #607d8b;
    }
    .paperlist-container {
      max-width: 1200px;
      margin: 0 auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      padding: 24px 24px 32px 24px;
      display: flex;
      flex-direction: row;
      gap: 32px;
    }
    .paperlist-main {
      flex: 1 1 0;
      min-width: 0;
    }
    .paperlist-controls {
      display: flex;
      align-items: center;
      gap: 24px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .paperlist-slider {
      flex: 1 1 0;
      min-width: 220px;
      max-width: 350px;
      margin-right: 12px;
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.95em;
      color: #888;
      margin-top: 2px;
      margin-bottom: 8px;
    }
    .paperlist-sort {
      min-width: 140px;
      font-size: 1em;
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f7f7f7;
      color: #333;
    }
    .paperlist-count {
      font-size: 1.1em;
      color: #444;
      margin-left: 8px;
    }
    .reset-btn {
      background: #e53935;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 7px 18px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      margin-left: 12px;
      transition: background 0.2s;
    }
    .reset-btn:hover {
      background: #b71c1c;
    }
    .paperlist-list {
      margin-top: 12px;
    }
    .paperlist-item {
      display: flex;
      align-items: flex-start;
      gap: 18px;
      padding: 18px 0 10px 0;
      border-bottom: 1px solid #eee;
    }
    .paperlist-item:last-child {
      border-bottom: none;
    }
    .paper-title {
      font-weight: bold;
      font-size: 1.08em;
      margin-bottom: 2px;
      color: #222;
      text-decoration: none;
    }
    .paper-title:hover {
      text-decoration: underline;
    }
    .paper-authors {
      color: #888;
      font-size: 0.98em;
      margin-bottom: 2px;
    }
    .paper-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 7px;
      margin-top: 2px;
    }
    .chip {
      display: inline-block;
      padding: 3px 12px;
      border-radius: 999px;
      font-size: 0.97em;
      font-weight: 500;
      background: #eee;
      color: #444;
      cursor: pointer;
      user-select: none;
      border: none;
      transition: background 0.2s, color 0.2s;
    }
    .chip.type {
      background: #43a047;
      color: #fff;
    }
    .chip.prior {
      background: #fff;
      color: #666;
      border: 1.5px solid #bbb;
    }
    .chip.selected {
      background: #1976d2;
      color: #fff;
    }
    .chip.pub {
      background: #ffb300;
      color: #fff;
      font-weight: 600;
      border: 1.5px solid #ffb300;
    }
    .chip.pub[variant="outlined"] {
      background: #fff3e0;
      color: #ff9800;
      border: 1.5px solid #ffb300;
    }
    .sidebar {
      min-width: 220px;
      max-width: 260px;
      padding-left: 12px;
      border-left: 1.5px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .sidebar-label {
      font-size: 1.08em;
      font-weight: 500;
      margin-bottom: 6px;
      color: #333;
    }
    .sidebar-chips {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-wrap: wrap;
    }
    @media (max-width: 900px) {
      .paperlist-container {
        flex-direction: column;
        gap: 0;
        padding: 10px 2vw 24px 2vw;
      }
      .sidebar {
        border-left: none;
        border-top: 1.5px solid #e0e0e0;
        margin-top: 24px;
        padding-left: 0;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 12px;
      }
      .sidebar-chips {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="alps-header">
    <div class="alps-header-bar">
      <a class="alps-title" href="http://expopt.org" style="color:inherit;text-decoration:none;">Home</a>
    </div>
  </div>
  <div class="paperlist-container">
    <div class="paperlist-main">
      <div class="paperlist-controls">
  <div class="paperlist-slider"></div>
  <div class="slider-labels" id="year-slider-labels"></div>
        <select id="sort-filter" class="paperlist-sort">
          <option value="desc">Newest first</option>
          <option value="asc">Oldest first</option>
        </select>
        <span class="paperlist-count" id="paper-count"></span>
        <button class="reset-btn" id="reset-filters" style="display:none;">Reset</button>
      </div>
      <div class="paperlist-list" id="papers-list"></div>
    </div>
    <div class="sidebar">
      <div class="sidebar-label">Filter by label</div>
      <div class="sidebar-chips" id="chip-filters"></div>
    </div>
  </div>
  <style>
    .alps-slider { position: relative; width: 100%; max-width: 360px; margin: 0 auto; height: 48px; user-select: none; }
    .alps-slider-track {
      position: absolute; left: 0; right: 0; top: 22px; height: 6px; background: #e0e0e0; border-radius: 3px; z-index: 1;
    }
    .alps-slider-fill {
      position: absolute; top: 22px; height: 6px; background: #1976d2; border-radius: 3px; z-index: 2;
    }
    .alps-slider-thumb {
      position: absolute; top: 10px; width: 28px; height: 28px; border-radius: 50%; background: #455a64; border: 3px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18); cursor: pointer; z-index: 3; display: flex; align-items: center; justify-content: center;
      transition: background 0.2s;
    }
    .alps-slider-thumb:active, .alps-slider-thumb:focus { background: #1976d2; outline: 2px solid #1976d2; }
    .alps-slider input[type=range] {
      position: absolute; top: 0; left: 0; width: 100%; height: 48px; opacity: 0; pointer-events: none;
    }
    .alps-slider-labels {
      display: flex; justify-content: space-between; font-size: 13px; color: #555; margin-top: 38px; margin-bottom: 0; width: 100%;
      pointer-events: none; user-select: none;
    }
    @media (max-width: 360px) {
      .alps-slider { max-width: 100%; }
      .alps-slider-labels { font-size: 12px; }
      .alps-slider-thumb { width: 24px; height: 24px; }
    }
  </style>
  <script>
    // --- PaperList logic ---
    const TYPE_LABELS = [
      "dynamic / data structure",
      "online",
      "running time",
      "approximation",
      "streaming",
      "game theory / mechanism design",
      "differential privacy",
      "survey"
    ];
    const PRIOR_LABEL = "prior/related work";
    let papers = [];
    let selectedLabels = [];
    let yearMin = 0, yearMax = 0, yearRange = [0,0], allYears = [];
    let allLabels = [];
    let yearSliderApi = null;
    // Fetch and preprocess papers
    fetch('/_data/papers.json')
      .then(r => r.json())
      .then(data => {
        papers = data.filter(p => typeof p === 'object' && p.title);
        // Extract all years from publications and paper.year
        allYears = Array.from(new Set(papers.flatMap(p => {
          let years = [];
          if (Array.isArray(p.publications)) years.push(...p.publications.map(pub => pub.year).filter(Boolean));
          if (p.year) years.push(p.year);
          return years;
        }))).filter(Boolean).sort((a,b)=>a-b);
        yearMin = allYears[0] || 2000;
        yearMax = allYears[allYears.length-1] || 2025;
        yearRange = [yearMin, yearMax];
        allLabels = Array.from(new Set(papers.flatMap(p => Array.isArray(p.labels) ? p.labels : [])));
        // Init new slider
        yearSliderApi = initYearSlider({
          container: document.querySelector('.paperlist-slider'),
          years: allYears,
          initial: [0, allYears.length-1],
          onChange: ({minIndex, maxIndex, minYear, maxYear}) => {
            yearRange = [minYear, maxYear];
            renderYearLabels();
            renderPapers();
          }
        });
        renderYearLabels();
        renderFilters();
        renderPapers();
      });

    function renderYearLabels() {
      const labelsCont = document.getElementById('year-slider-labels');
      if (!labelsCont) return;
      let n = allYears.length <= 7 ? allYears.length : Math.max(6, Math.min(10, allYears.length));
      let idxs = [];
      for (let i = 0; i < n; ++i) {
        idxs.push(Math.round(i*(allYears.length-1)/(n-1)));
      }
      let html = '<div class="alps-slider-labels">';
      for (let i = 0; i < idxs.length; ++i) {
        html += `<span>${allYears[idxs[i]]}</span>`;
      }
      html += '</div>';
      labelsCont.innerHTML = html;
    }
    function renderFilters() {
      let chipFilters = document.getElementById('chip-filters');
      chipFilters.innerHTML = '';
      // Show type labels first, then prior, then others
      TYPE_LABELS.concat([PRIOR_LABEL]).forEach(label => { chipFilters.appendChild(labelChip(label)); });
      allLabels.filter(l => !TYPE_LABELS.includes(l) && l !== PRIOR_LABEL).sort().forEach(label => { chipFilters.appendChild(labelChip(label)); });
    }
    function labelChip(label) {
      const span = document.createElement('span');
      span.className = 'chip';
      if (TYPE_LABELS.includes(label)) span.classList.add('type');
      if (label === PRIOR_LABEL) span.classList.add('prior');
      if (selectedLabels.includes(label)) span.classList.add('selected');
      span.textContent = label;
      span.onclick = () => {
        if (selectedLabels.includes(label)) {
          selectedLabels = selectedLabels.filter(l => l !== label);
        } else {
          selectedLabels = [label, ...selectedLabels];
        }
        renderFilters();
        renderPapers();
      };
      return span;
    }
    document.getElementById('reset-filters').onclick = function() {
      selectedLabels = [];
      if (yearSliderApi) yearSliderApi.setIndices([0, allYears.length-1]);
      yearRange = [yearMin, yearMax];
      document.getElementById('sort-filter').value = 'desc';
      renderFilters();
      renderPapers();
    };
    document.getElementById('sort-filter').onchange = function() {
      renderPapers();
    };
    function renderPapers() {
      const sort = document.getElementById('sort-filter').value;
      let filtered = papers.filter(p => {
        // Find all years for this paper
        let years = [];
        if (Array.isArray(p.publications)) years.push(...p.publications.map(pub => pub.year).filter(Boolean));
        if (p.year) years.push(p.year);
        let minYear = Math.min(...years);
        let maxYear = Math.max(...years);
        let match = true;
        if (minYear > yearRange[1] || maxYear < yearRange[0]) match = false;
        if (selectedLabels.length > 0) {
          if (!Array.isArray(p.labels) || !selectedLabels.every(t => p.labels.includes(t))) match = false;
        }
        return match;
      });
      filtered.sort((a, b) => {
        // Sort by max year in publications or paper.year
        let ay = [];
        if (Array.isArray(a.publications)) ay.push(...a.publications.map(pub => pub.year).filter(Boolean));
        if (a.year) ay.push(a.year);
        let by = [];
        if (Array.isArray(b.publications)) by.push(...b.publications.map(pub => pub.year).filter(Boolean));
        if (b.year) by.push(b.year);
        let aYear = sort === 'desc' ? Math.max(...ay) : Math.min(...ay);
        let bYear = sort === 'desc' ? Math.max(...by) : Math.min(...by);
        return sort === 'desc' ? (bYear - aYear) : (aYear - bYear);
      });
      document.getElementById('paper-count').textContent = `${filtered.length} papers`;
      const container = document.getElementById('papers-list');
      container.innerHTML = '';
      filtered.forEach(paper => {
        const div = document.createElement('div');
        div.className = 'paperlist-item';
        // Publication chips (arXiv, CPM, etc.)
        let pubChips = '';
        if (Array.isArray(paper.publications)) {
          pubChips = paper.publications.map(pub => {
            let name = pub.displayName || pub.name || '';
            let text = name + (pub.year ? ` '${String(pub.year).slice(-2)}` : '');
            let variant = (name === 'arXiv') ? 'outlined' : 'filled';
            return `<span class='chip pub' variant='${variant}' onclick='window.open("${pub.url||'#'}","_blank")'>${text}</span>`;
          }).join(' ');
        }
        // Label chips
        let labelChips = '';
        if (Array.isArray(paper.labels)) {
          labelChips = paper.labels.map(l => {
            let cls = 'chip';
            if (TYPE_LABELS.includes(l)) cls += ' type';
            if (l === PRIOR_LABEL) cls += ' prior';
            return `<span class='${cls}'>${l}</span>`;
          }).join(' ');
        }
        div.innerHTML = `
          <div style="flex:1;min-width:0;">
            <div class="paper-title">${paper.url ? `<a href='${paper.url}' target='_blank'>${paper.title}</a>` : paper.title}</div>
            <div class="paper-authors">${paper.authors || ''}</div>
            <div class="paper-chips">${pubChips} ${labelChips}</div>
          </div>
        `;
        container.appendChild(div);
      });
      document.getElementById('reset-filters').style.display = (selectedLabels.length || (yearRange[0] !== yearMin || yearRange[1] !== yearMax)) ? '' : 'none';
    }

    // --- Accessible, responsive, dual-thumb year slider ---
    function initYearSlider({ container, years, initial, onChange }) {
      container.innerHTML = '';
      const slider = document.createElement('div');
      slider.className = 'alps-slider';
      const track = document.createElement('div');
      track.className = 'alps-slider-track';
      slider.appendChild(track);
      const fill = document.createElement('div');
      fill.className = 'alps-slider-fill';
      slider.appendChild(fill);
      const thumbMin = document.createElement('div');
      thumbMin.className = 'alps-slider-thumb';
      thumbMin.tabIndex = 0;
      thumbMin.id = 'year-range-min';
      thumbMin.setAttribute('role', 'slider');
      thumbMin.setAttribute('aria-label', 'Minimum year');
      slider.appendChild(thumbMin);
      const thumbMax = document.createElement('div');
      thumbMax.className = 'alps-slider-thumb';
      thumbMax.tabIndex = 0;
      thumbMax.id = 'year-range-max';
      thumbMax.setAttribute('role', 'slider');
      thumbMax.setAttribute('aria-label', 'Maximum year');
      slider.appendChild(thumbMax);
      // Hidden range inputs for accessibility
      const inputMin = document.createElement('input');
      inputMin.type = 'range';
      inputMin.min = 0; inputMin.max = years.length-1; inputMin.step = 1;
      inputMin.value = initial[0];
      inputMin.id = 'year-range-min';
      slider.appendChild(inputMin);
      const inputMax = document.createElement('input');
      inputMax.type = 'range';
      inputMax.min = 0; inputMax.max = years.length-1; inputMax.step = 1;
      inputMax.value = initial[1];
      inputMax.id = 'year-range-max';
      slider.appendChild(inputMax);
      container.appendChild(slider);
      // Labels
      const labelsCont = document.getElementById('year-slider-labels');
      function renderLabels() {
        if (!labelsCont) return;
        let n = years.length <= 7 ? years.length : Math.max(6, Math.min(10, years.length));
        let idxs = [];
        for (let i = 0; i < n; ++i) {
          idxs.push(Math.round(i*(years.length-1)/(n-1)));
        }
        let html = '<div class="alps-slider-labels">';
        for (let i = 0; i < idxs.length; ++i) {
          html += `<span>${years[idxs[i]]}</span>`;
        }
        html += '</div>';
        labelsCont.innerHTML = html;
      }
      renderLabels();
      // State
      let minIdx = initial[0], maxIdx = initial[1];
      function clampIdxs() {
        minIdx = Math.max(0, Math.min(minIdx, maxIdx));
        maxIdx = Math.min(years.length-1, Math.max(maxIdx, minIdx));
      }
      function percent(idx) { return (idx/(years.length-1))*100; }
      function updateUI() {
        clampIdxs();
        thumbMin.style.left = `calc(${percent(minIdx)}% - 14px)`;
        thumbMax.style.left = `calc(${percent(maxIdx)}% - 14px)`;
        fill.style.left = percent(minIdx) + '%';
        fill.style.width = (percent(maxIdx)-percent(minIdx)) + '%';
        // ARIA
        thumbMin.setAttribute('aria-valuemin', 0);
        thumbMin.setAttribute('aria-valuemax', years.length-1);
        thumbMin.setAttribute('aria-valuenow', minIdx);
        thumbMin.setAttribute('aria-valuetext', years[minIdx]);
        thumbMax.setAttribute('aria-valuemin', 0);
        thumbMax.setAttribute('aria-valuemax', years.length-1);
        thumbMax.setAttribute('aria-valuenow', maxIdx);
        thumbMax.setAttribute('aria-valuetext', years[maxIdx]);
        inputMin.value = minIdx;
        inputMax.value = maxIdx;
      }
      function fireChange() {
        if (typeof onChange === 'function') {
          onChange({ minIndex: minIdx, maxIndex: maxIdx, minYear: years[minIdx], maxYear: years[maxIdx] });
        }
      }
      // Drag logic
      let dragging = null;
      function onPointerDown(e, which) {
        dragging = which;
        document.body.style.userSelect = 'none';
        e.preventDefault();
      }
      function onPointerMove(e) {
        if (!dragging) return;
        let rect = track.getBoundingClientRect();
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        x = Math.max(0, Math.min(x, rect.width));
        let idx = Math.round((x/rect.width)*(years.length-1));
        if (dragging === 'min') {
          minIdx = Math.min(idx, maxIdx);
        } else {
          maxIdx = Math.max(idx, minIdx);
        }
        updateUI();
        fireChange();
      }
      function onPointerUp() {
        dragging = null;
        document.body.style.userSelect = '';
      }
      thumbMin.addEventListener('mousedown', e => onPointerDown(e, 'min'));
      thumbMax.addEventListener('mousedown', e => onPointerDown(e, 'max'));
      thumbMin.addEventListener('touchstart', e => onPointerDown(e, 'min'), {passive:false});
      thumbMax.addEventListener('touchstart', e => onPointerDown(e, 'max'), {passive:false});
      window.addEventListener('mousemove', onPointerMove);
      window.addEventListener('touchmove', onPointerMove, {passive:false});
      window.addEventListener('mouseup', onPointerUp);
      window.addEventListener('touchend', onPointerUp);
      // Range input (for accessibility)
      inputMin.addEventListener('input', e => {
        minIdx = Math.min(Number(inputMin.value), maxIdx);
        updateUI();
        fireChange();
      });
      inputMax.addEventListener('input', e => {
        maxIdx = Math.max(Number(inputMax.value), minIdx);
        updateUI();
        fireChange();
      });
      // Keyboard
      function handleKey(e, which) {
        let idx = which === 'min' ? minIdx : maxIdx;
        let min = 0, max = years.length-1;
        let step = 1;
        switch (e.key) {
          case 'ArrowLeft': idx = Math.max(min, idx-1); break;
          case 'ArrowRight': idx = Math.min(max, idx+1); break;
          case 'PageUp': idx = Math.min(max, idx+5); break;
          case 'PageDown': idx = Math.max(min, idx-5); break;
          case 'Home': idx = min; break;
          case 'End': idx = max; break;
          default: return;
        }
        if (which === 'min') minIdx = Math.min(idx, maxIdx);
        else maxIdx = Math.max(idx, minIdx);
        updateUI();
        fireChange();
        e.preventDefault();
      }
      thumbMin.addEventListener('keydown', e => handleKey(e, 'min'));
      thumbMax.addEventListener('keydown', e => handleKey(e, 'max'));
      // Resize
      window.addEventListener('resize', updateUI);
      // Initial
      updateUI();
      // API
      return {
        getIndices: () => [minIdx, maxIdx],
        setIndices: ([a, b]) => { minIdx = Math.max(0, Math.min(a, b)); maxIdx = Math.min(years.length-1, Math.max(a, b)); updateUI(); fireChange(); }
      };
    }
  </script>
</body>
</html>